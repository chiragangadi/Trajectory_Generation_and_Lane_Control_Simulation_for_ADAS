[Version]
10.1.1.1057
[File Access]
0   
45845
! 
! 
! 
! 
! 
! 
! 
! 
3   1
pos_y
3   1
pos_x
4   1
psi
5   1
lateral distance
2   1
[Export Parameter Count]
0
[Block Count]
6
[Block #0]
385   USER1
Lateral Distance Computation
450 125 521 191  100   16777215   0   0 
3
2
0 0 0   0   1
C:\Program Files (x86)\Kahlert\WinFACT 10\UserDLLs\PyScript.dll
*.*
1 0 0   0
0
1
182
# In der folgenden Zeile wird die Anzahl der Ausg‰nge festgelegt (hier 2):
# nOut = 2
# In den folgenden drei Zeilen werden die Namen der Ausg‰nge 
# festgelegt (kann entfallen, dann werden Standardnamen gew‰hlt)
# Out_1 = "Lateral distance" 
# Out_2 = "exit simulation"

# Nachfolgend wird die eigentliche Funktion deklariert
# Sie MUSS "main" heiﬂen!
# Die Anzahl der Blockeing‰nge (hier 3) wird automatisch
# aus der Parameterliste erkannt, ebenso die Namen der 
# Blockeing‰nge (hier psi, pos_x, pos_y)

import math

# Global variables
X_route = []
Y_route = []
data_read = 0
i_smaller_old = 0

# file_operations is user defined function to read file, replace ',' to '.' if it contains and to store in a list.
def file_operations(datapath, array):
    with open(datapath, 'r') as f:
        content = f.read()
        modified_content = content.replace(',' , '.')
    with open(datapath, 'w') as f:
        f.write(modified_content)
    with open(datapath, 'r') as f:
        for org_line in f:
            array.append(float(org_line))

def main(Init, Terminate, psi, pos_x, pos_y):
    global X_route, Y_route, data_read, i_smaller_old

    # Variables for data file operations
    dataPath_X = "lane1_X_right.txt"   # Give file if file is present in same directory
    dataPath_Y = "lane1_Y_right.txt"   # Give full path if file is in different directory  
    x_read, y_read = 0, 0
    
    
    # Variables for computations
    p_x, p_y = 0, 0
    q_x, q_y = 0, 0
    i, i_smaller = 0, 0
    condition_point = 0
    dx1, dy1, dx2, dy2, l1, l2 = 0, 0, 0, 0, 0, 0
    nx1, ny1, nx2, ny2 = 0, 0, 0, 0
    rho1, rho2 = 0, 0
    det_1, det_2, det_3, det_4 = 0, 0, 0, 0
    e_x, e_y = 0, 0
    lateral_distance = 0
    
    # The constant pi needs to be defined
    pi = 3.1415926535

    # During the initialization of the simulation Init = 1
    if Init == 1:
        
        # Reading the file containing the complete trajectory in X coordinates and storing in new array
        try:
            file_operations(dataPath_X, X_route)
            x_read = 1
        except FileNotFoundError:
            pass
            
        # Reading the file containing the complete trajectory in Y coordinates and storing in new array
        try:
            file_operations(dataPath_Y, Y_route)
            y_read = 1
        except FileNotFoundError:
            pass
        # IF else statements for checking route data of x and y coordinates have been read correctly or not
        if x_read == 1 and y_read == 1:
            # Below code is executed if both the files are read
            if len(X_route) == len(Y_route):
                # Condition for identical number of coordinates in both X and Y
                data_read = 1
            else:
                # If one of the file has incorrect number of coordinates
                print("One of the data files is incorrect")
                print("The simulation is terminated!")
                data_read = 0
        else:
            # If one or both the files are not read
            print("One of the data files could not be read!")
            print("The simulation is terminated!")
            data_read = 0
        
        lateral_distance = 1.5     # Initialize output variable
       
        
    # After the simulation, Terminate = 1 is set for a call
    elif Terminate == 1:
        print("Termination takes place!")
        Terminate()
        
    if data_read == 1:
        # The following lines of code are executed in every simulation step after the data files are completely read
            
        # Computation to determine the point P
        p_x = pos_x + 10 * math.cos(psi)
        p_y = pos_y + 10 * math.sin(psi)
            
        # Computation to determine the auxiliary point Q
        q_x = p_x + 10 * math.cos(psi - (pi/2))
        q_y = p_y + 10 * math.sin(psi - (pi/2))
            
        # Find the maximum value of the index i for which the condition is less than or equal to zero ...
        i = i_smaller_old
        condition_point = (q_x - p_x) * (Y_route[i] - p_y) - (X_route[i] - p_x) * (q_y - p_y)
            
        while condition_point <= 0 and i <= len(X_route) - 2:
            if condition_point <= 0:
                i_smaller = i
                
            i += 1
                
            if i >= len(X_route):
                i = len(X_route) - 1
                
            condition_point = (q_x - p_x) * (Y_route[i] - p_y) - (X_route[i] - p_x) * (q_y - p_y)
            
        i_smaller_old = i_smaller  # Save the current "i_smaller" for the next run
         
        # Components of the line by connecting the two vertices of the "edge of the road"   
        dx1 = X_route[i_smaller + 1] - X_route[i_smaller]
        dy1 = Y_route[i_smaller + 1] - Y_route[i_smaller]
        
        # Components of the line by connecting points P and Q    
        dx2 = q_x - p_x
        dy2 = q_y - p_y
        
        # Calculating the length of the connecting lines    
        l1 = math.sqrt(dx1*dx1 + dy1*dy1)
        l2 = math.sqrt(dx2*dx2 + dy2*dy2)
        
        # Components of the normal vector, perpendicular to the polygon chain    
        nx1 = dy1 / l1
        ny1 = -1 * (dx1 / l1)
        
        # Components of the normal vector, perpendicular to the line PQ    
        nx2 = dy2 / l2
        ny2 = -1 * (dx2 / l2)
        
        # Calculate the distance parameter Rho for the Hessian normal form of the two straight lines    
        rho1 = nx1 * X_route[i_smaller] + ny1 * Y_route[i_smaller]
        rho2 = nx2 * p_x + ny2 * p_y
        
        # Calculate the intersection of the straight lines using Cramerís rule
        # For Cramerís rule and lienar equations refer to:    
        det_1 = rho1 * ny2 - rho2 * ny1
        det_2 = nx1 * ny2 - ny1 * nx2
        det_3 = nx1 * rho2 - nx2 * rho1
        det_4 = nx1 * ny2 - nx2 * ny1
            
        e_x = det_1 / det_2
        e_y = det_3 / det_4
        
        # Calculate the value of the lateral distance    
        lateral_distance = math.sqrt((e_x - p_x)**2 + (e_y - p_y)**2)
        
        # Check if the point P is to the right or left edge of the road with respect to the centre of gravity of the vehicle    
        condition_point = (e_x - pos_x) * (p_y - pos_y) - (p_x - pos_x) * (e_y - pos_y)
        
        # If the point P is to the right of the edge of line, the sign of the lateral distance must be corrected    
        if condition_point < 0:
            lateral_distance *= -1
            
    else:
        # If the data files have not been completely read, a constant value is assigned to the outputs
        lateral_distance = 1.5
    
    Out_1.value = lateral_distance
    
    # If the data file have not been read completely, the output 2 "exit_simulation" is assigned with the value of 5 == logic 1 and the simulation in the higher level module is ended. 
    # However, if the data files have been read completely, the output 2 "exit_simulation" is assigned with the value of 0 and the simulation runs normally.

    if data_read == 0:
        Out_2.value = 5
    else:
        Out_2.value = 0
3
psi
pos_x
pos_y
2
Lateral distance
exit simulation
0
0
1
1
[Block #1]
378   SIMCANCEL
SIMCANCEL
625 175 696 226  100   16777215   0   0 
1
0
0 0 0   0   0
0
[Block #2]
384   LABEL
lateral distance
625 100 696 132  100   16777215   0   0 
1
1
0 0 0   0   0
[Block #3]
384   LABEL
pos_y
225 225 296 257  100   16777215   0   0 
1
1
0 0 0   0   0
[Block #4]
384   LABEL
pos_x
225 175 296 207  100   16777215   0   0 
1
1
0 0 0   0   0
[Block #5]
384   LABEL
psi
225 125 296 157  100   16777215   0   0 
1
1
0 0 0   0   0
[Connection Count]
5
[Connection #0]
0   1   2   1   16711680   -1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0
0
9
[Connection #1]
0   2   1   1   16711680   -1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0
0
9
[Connection #2]
5   1   0   1   16711680   -1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0
0
9
[Connection #3]
4   1   0   2   16711680   -1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0
0
9
[Connection #4]
3   1   0   3   16711680   -1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0
0
9
[Simulation Parameters]
 1.00000000000000E+0001    1.00000000000000E-0002   0   2   1  0   1   1   0   0   4   0   0
[Logical Levels]
 0.00000000000000E+0000    5.00000000000000E+0000    2.50000000000000E+0000
[Frame Count]
0
[Optimization Parameters Count]
0
[Optimization Control Parameters]
20   5   100   3   10   1   10   1   12345
 1.00000000000000E+0000    0.00000000000000E+0000    0.00000000000000E+0000
OPT.DAT
0
1
[Batch Parameters Count]
0
[Global Parameters]
0
[Message Options]
BORIS.MSG
[User Background Bitmap]
0

[Scrollbars]
0   0
[Control Codes]
DEE248F3CAF2709815781CE3A95DCB7388518DA9
B01A2C0E306E90CCBCB51854F4A7664B5A4D79B7
